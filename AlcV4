-- Optimized Potion Crafter Script
-- Enhanced performance, error handling, and logic optimization

local WhitelistURL = 'https://raw.githubusercontent.com/HiddenUserAnomaly/Hidden/refs/heads/main/Whitelist'
local Players = game:GetService('Players')
local ReplicatedStorage = game:GetService('ReplicatedStorage')
local UserInputService = game:GetService('UserInputService')
local RunService = game:GetService('RunService')
local TweenService = game:GetService('TweenService')
local HttpService = game:GetService('HttpService')

-- Cache frequently used services and functions
local task = task
local table_insert = table.insert
local table_remove = table.remove
local math_max = math.max
local tick = tick
local pcall = pcall
local typeof = typeof
local tostring = tostring

local localPlayer = Players.LocalPlayer
local username = localPlayer.Name

-- Optimized whitelist check with caching
local WHITELIST_CACHE = {
    data = nil,
    lastFetch = 0,
    cacheTime = 30 -- Cache for 30 seconds
}

local function checkWhitelist()
    -- Use cached data if available and not expired
    local currentTime = tick()
    if WHITELIST_CACHE.data and (currentTime - WHITELIST_CACHE.lastFetch) < WHITELIST_CACHE.cacheTime then
        return WHITELIST_CACHE.data
    end

    local success, response = pcall(function()
        return game:HttpGet(WhitelistURL, true)
    end)

    if not success then
        warn('âŒ Failed to fetch whitelist: ' .. tostring(response))
        WHITELIST_CACHE.data = false
        return false
    end

    if not response or response == '' then
        warn('âŒ Whitelist response was empty')
        WHITELIST_CACHE.data = false
        return false
    end

    -- Optimized whitelist parsing
    local whitelist = {}
    local lowerUsername = username:lower()
    local found = false
    
    for line in response:gmatch('[^\r\n]+') do
        local cleanUsername = line:match('^%s*(.-)%s*$'):lower()
        if cleanUsername ~= '' then
            if cleanUsername == lowerUsername then
                found = true
                break
            end
            table_insert(whitelist, cleanUsername)
        end
    end

    WHITELIST_CACHE.data = found
    WHITELIST_CACHE.lastFetch = currentTime
    
    if found then
        print('âœ… Username ' .. username .. ' found in whitelist')
    else
        warn('âŒ Username ' .. username .. ' not found in whitelist')
    end
    
    return found
end

-- Exit if not whitelisted
if not checkWhitelist() then
    warn('ðŸš« Script execution blocked: User not whitelisted')
    return 
end

print('Welcome, ' .. username .. '! Script execution authorized.')

-- OPTIMIZED KEYBIND SAVING SYSTEM (Preserved as requested)
local KeybindManager = {
    SettingsFolder = 'workspace/PotionScriptSettings',
    KeybindsFile = 'workspace/PotionScriptSettings/Keybinds.json',
}

-- Helper function for key names
local function keyToString(k)
    if not k then return 'None' end
    if typeof(k) == 'EnumItem' then
        return tostring(k):gsub('Enum.KeyCode.', '')
    end
    return tostring(k)
end

-- Initialize settings folder
function KeybindManager:InitializeSettings()
    if not isfolder(self.SettingsFolder) then
        makefolder(self.SettingsFolder)
    end
end

-- Load keybinds from file
function KeybindManager:LoadKeybinds()
    if not isfile(self.KeybindsFile) then return nil end
    
    local success, data = pcall(readfile, self.KeybindsFile)
    if not success or not data then return nil end
    
    local success, decoded = pcall(HttpService.JSONDecode, HttpService, data)
    return success and decoded or nil
end

-- Save keybinds to file
function KeybindManager:SaveKeybinds()
    self:InitializeSettings()

    local keybindsToSave = {
        Sleep = keyToString(getgenv().PotionKeybinds.Sleep),
        Heal = keyToString(getgenv().PotionKeybinds.Heal),
        Shield = keyToString(getgenv().PotionKeybinds.Shield),
        Poison = keyToString(getgenv().PotionKeybinds.Poison),
        AutoCollection = keyToString(getgenv().PotionKeybinds.AutoCollection),
        GUIToggle = keyToString(getgenv().GUIToggleKeybind),
    }

    local success, encoded = pcall(HttpService.JSONEncode, HttpService, keybindsToSave)
    if success and encoded then
        writefile(self.KeybindsFile, encoded)
        print('ðŸ’¾ Keybinds saved successfully!')
        return true
    end
    warn('âŒ Failed to save keybinds')
    return false
end

-- Initialize keybind system
KeybindManager:InitializeSettings()
local savedKeybinds = KeybindManager:LoadKeybinds()

-- Set up default keybinds first
getgenv().PotionToggles = {
    Sleep = false,
    Heal = false,
    Shield = false,
    Poison = false,
    AutoCollection = true,
}

-- Default keybinds
getgenv().PotionKeybinds = {
    Sleep = Enum.KeyCode.Home,
    Heal = Enum.KeyCode.PageUp,
    Shield = Enum.KeyCode.Delete,
    Poison = Enum.KeyCode.F10,
    AutoCollection = Enum.KeyCode.F6,
}

getgenv().GUIToggleKeybind = Enum.KeyCode.PageDown

-- Load saved keybinds if they exist
if savedKeybinds then
    local function stringToKeyCode(keyString)
        if keyString and keyString ~= 'None' then
            local success, keyCode = pcall(function()
                return Enum.KeyCode[keyString]
            end)
            if success and keyCode then
                return keyCode
            end
        end
        return nil
    end

    -- Update keybinds with saved values using direct assignment
    getgenv().PotionKeybinds.Sleep = stringToKeyCode(savedKeybinds.Sleep) or Enum.KeyCode.Home
    getgenv().PotionKeybinds.Heal = stringToKeyCode(savedKeybinds.Heal) or Enum.KeyCode.PageUp
    getgenv().PotionKeybinds.Shield = stringToKeyCode(savedKeybinds.Shield) or Enum.KeyCode.Delete
    getgenv().PotionKeybinds.Poison = stringToKeyCode(savedKeybinds.Poison) or Enum.KeyCode.F10
    getgenv().PotionKeybinds.AutoCollection = stringToKeyCode(savedKeybinds.AutoCollection) or Enum.KeyCode.F6
    getgenv().GUIToggleKeybind = stringToKeyCode(savedKeybinds.GUIToggle) or Enum.KeyCode.PageDown

    print('âœ… Loaded saved keybinds')
else
    print('â„¹ï¸ Using default keybinds')
end

-- OPTIMIZED SERVICE REFERENCES
local player = Players.LocalPlayer

-- REMOTE CACHING WITH ERROR HANDLING
local craftRemote, collectRemote

local function initializeRemotes()
    local success
    success, craftRemote = pcall(function()
        return ReplicatedStorage:WaitForChild('rbxts_include')
            :WaitForChild('node_modules')
            :WaitForChild('@rbxts')
            :WaitForChild('net')
            :WaitForChild('out')
            :WaitForChild('_NetManaged')
            :WaitForChild('CraftingEntityInteract', 10)
    end)
    
    if not success then
        warn('âŒ Failed to find craftRemote')
        craftRemote = nil
    end

    success, collectRemote = pcall(function()
        return ReplicatedStorage:WaitForChild('rbxts_include')
            :WaitForChild('node_modules')
            :WaitForChild('@rbxts')
            :WaitForChild('net')
            :WaitForChild('out')
            :WaitForChild('_NetManaged')
            :WaitForChild('CollectCollectableEntity', 10)
    end)
    
    if not success then
        warn('âŒ Failed to find collectRemote')
        collectRemote = nil
    end
end

initializeRemotes()

-- OPTIMIZED CRAFTING SETTINGS
local depositInterval = 0.2
local craftWait = 5.5

-- OPTIMIZED CAULDRON MANAGEMENT
local cauldronAssignments = {}
local cauldronCache = {
    data = nil,
    lastScan = 0,
    cacheTime = 5 -- Cache cauldrons for 5 seconds
}

-- OPTIMIZED AUTO-COLLECTION VARIABLES
local AutoCollectionEnabled = true
local HeartbeatConnection = nil
local LastScanTime = 0
local ScanInterval = 0.5
local ScanCount = 0
local resourceNames = { 'Flower', 'Mushrooms', 'Thorns' }

-- OPTIMIZED CAULDRON FINDING WITH CACHING
local function findAllCauldronsSorted()
    local currentTime = tick()
    if cauldronCache.data and (currentTime - cauldronCache.lastScan) < cauldronCache.cacheTime then
        return cauldronCache.data
    end

    local cauldrons = {}
    local char = player.Character
    local charPosition = char and char.PrimaryPart and char.PrimaryPart.Position
    
    -- Fast scanning using GetDescendants
    local descendants = workspace:GetDescendants()
    for i = 1, #descendants do
        local obj = descendants[i]
        if obj:IsA('BasePart') and obj.Name == 'brewing_cauldron' then
            table_insert(cauldrons, obj)
        end
    end

    -- Sort by distance if character exists
    if charPosition and #cauldrons > 0 then
        table.sort(cauldrons, function(a, b)
            local distA = (a.Position - charPosition).Magnitude
            local distB = (b.Position - charPosition).Magnitude
            return distA < distB
        end)
    end

    cauldronCache.data = cauldrons
    cauldronCache.lastScan = currentTime
    
    return cauldrons
end

-- OPTIMIZED CAULDRON ASSIGNMENT
local function getAvailableCauldrons()
    local allCauldrons = findAllCauldronsSorted()
    local available = {}

    for i = 1, #allCauldrons do
        local cauldron = allCauldrons[i]
        local isAssigned = false
        
        for potionType, assignedCauldron in pairs(cauldronAssignments) do
            if assignedCauldron == cauldron and getgenv().PotionToggles[potionType] then
                isAssigned = true
                break
            end
        end
        
        if not isAssigned then
            table_insert(available, cauldron)
        end
    end

    return available
end

local function assignCauldronToPotion(potionType)
    local available = getAvailableCauldrons()
    if #available > 0 then
        cauldronAssignments[potionType] = available[1]
        return true
    end
    return false
end

local function releaseCauldron(potionType)
    cauldronAssignments[potionType] = nil
end

local function getAssignedCauldron(potionType)
    return cauldronAssignments[potionType]
end

-- OPTIMIZED INVENTORY HELPERS
local inventoryCache = {
    data = nil,
    lastCheck = 0,
    cacheTime = 1
}

local function getInventory()
    local currentTime = tick()
    if inventoryCache.data and (currentTime - inventoryCache.lastCheck) < inventoryCache.cacheTime then
        return inventoryCache.data
    end

    local inv = ReplicatedStorage:FindFirstChild('Inventories')
    inv = inv and inv:FindFirstChild(player.Name)
    
    inventoryCache.data = inv
    inventoryCache.lastCheck = currentTime
    
    return inv
end

local function getItemCount(name)
    local inv = getInventory()
    if not inv then return 0 end

    local item = inv:FindFirstChild(name)
    return item and (item:GetAttribute('Amount') or 0) or 0
end

local function deductItem(name, amount)
    local inv = getInventory()
    if not inv then return end

    local item = inv:FindFirstChild(name)
    if item then
        local current = item:GetAttribute('Amount') or 0
        item:SetAttribute('Amount', math_max(current - amount, 0))
    end
end

-- OPTIMIZED DEPOSIT FUNCTION WITH ERROR HANDLING
local function depositItem(cauldron, item)
    if not cauldron or not craftRemote then return false end

    local id = cauldron:GetAttribute('id')
    if not id then return false end

    local success = pcall(function()
        craftRemote:FireServer({
            craftingEntity = {
                itemType = 'brewing_cauldron',
                position = cauldron.Position,
                id = id,
                owner = player,
                craftingBlock = cauldron,
            },
            itemInHand = item,
            amount = 1,
        })
    end)

    if success then
        deductItem(item, 1)
        return true
    end
    return false
end

-- OPTIMIZED COLLECT FUNCTION
local function collectPotion(cauldron)
    if not cauldron or not craftRemote then return false end

    local id = cauldron:GetAttribute('id')
    if not id then return false end

    local success = pcall(function()
        craftRemote:FireServer({
            craftingEntity = {
                itemType = 'brewing_cauldron',
                position = cauldron.Position,
                id = id,
                owner = player,
                craftingBlock = cauldron,
            },
            itemInHand = '',
        })
    end)

    return success
end

-- OPTIMIZED GUI SETUP
local ScreenGui = Instance.new('ScreenGui')
ScreenGui.Name = 'PotionToggleGui'
ScreenGui.ResetOnSpawn = false
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
ScreenGui.Parent = player:WaitForChild('PlayerGui')

local Frame = Instance.new('Frame')
Frame.Size = UDim2.new(0, 350, 0, 380)
Frame.Position = UDim2.new(0, 20, 0, 20)
Frame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
Frame.BorderSizePixel = 0
Frame.Parent = ScreenGui
Frame.Active = true
Frame.Draggable = true

local UICorner = Instance.new('UICorner')
UICorner.CornerRadius = UDim.new(0, 8)
UICorner.Parent = Frame

local UIStroke = Instance.new('UIStroke')
UIStroke.Parent = Frame
UIStroke.Thickness = 2
UIStroke.Color = Color3.fromRGB(60, 60, 60)

-- Title with GUI toggle info
local Title = Instance.new('TextLabel')
Title.Size = UDim2.new(1, 0, 0, 40)
Title.Position = UDim2.new(0, 0, 0, 0)
Title.BackgroundTransparency = 1
Title.Text = 'Potion Crafter\nHide: [' .. keyToString(getgenv().GUIToggleKeybind) .. ']'
Title.TextColor3 = Color3.fromRGB(255, 255, 255)
Title.Font = Enum.Font.GothamBold
Title.TextSize = 16
Title.TextYAlignment = Enum.TextYAlignment.Top
Title.Parent = Frame

-- GUI Toggle Rebind Button
local guiRebindBtn = Instance.new('TextButton')
guiRebindBtn.Size = UDim2.new(0, 80, 0, 20)
guiRebindBtn.Position = UDim2.new(1, -90, 0, 25)
guiRebindBtn.Text = 'Rebind GUI'
guiRebindBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
guiRebindBtn.TextColor3 = Color3.fromRGB(200, 200, 200)
guiRebindBtn.Font = Enum.Font.Gotham
guiRebindBtn.TextSize = 10
guiRebindBtn.Parent = Frame

local guiRebindListening = false

-- OPTIMIZED POTION ROW CREATION
local potionRows = {}

local function createPotionRow(potionType, yPosition, ingredients, isAutoCollection)
    local container = Instance.new('Frame')
    container.Size = UDim2.new(1, -20, 0, 55)
    container.Position = UDim2.new(0, 10, 0, yPosition + 40)
    container.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    container.BorderSizePixel = 0
    container.Parent = Frame

    local corner = Instance.new('UICorner')
    corner.CornerRadius = UDim.new(0, 6)
    corner.Parent = container

    -- Potion name
    local nameLabel = Instance.new('TextLabel')
    nameLabel.Size = UDim2.new(0, 100, 0, 25)
    nameLabel.Position = UDim2.new(0, 10, 0, 5)
    nameLabel.BackgroundTransparency = 1
    nameLabel.Text = potionType
    nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    nameLabel.Font = Enum.Font.Gotham
    nameLabel.TextSize = 14
    nameLabel.TextXAlignment = Enum.TextXAlignment.Left
    nameLabel.Parent = container

    -- Keybind display
    local keyLabel = Instance.new('TextLabel')
    keyLabel.Size = UDim2.new(0, 60, 0, 20)
    keyLabel.Position = UDim2.new(0, 110, 0, 5)
    keyLabel.BackgroundTransparency = 1
    keyLabel.Text = '[' .. keyToString(getgenv().PotionKeybinds[potionType]) .. ']'
    keyLabel.TextColor3 = Color3.fromRGB(180, 180, 180)
    keyLabel.Font = Enum.Font.Gotham
    keyLabel.TextSize = 12
    keyLabel.Parent = container

    -- Rebind button
    local rebindBtn = Instance.new('TextButton')
    rebindBtn.Size = UDim2.new(0, 60, 0, 20)
    rebindBtn.Position = UDim2.new(0, 180, 0, 5)
    rebindBtn.Text = 'Rebind'
    rebindBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    rebindBtn.TextColor3 = Color3.fromRGB(200, 200, 200)
    rebindBtn.Font = Enum.Font.Gotham
    rebindBtn.TextSize = 11
    rebindBtn.Parent = container

    -- Toggle indicator
    local toggle = Instance.new('TextButton')
    toggle.Size = UDim2.new(0, 20, 0, 20)
    toggle.Position = UDim2.new(1, -30, 0, 5)
    toggle.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
    toggle.BorderSizePixel = 0
    toggle.Text = ''
    toggle.AutoButtonColor = false
    toggle.Parent = container

    local toggleCorner = Instance.new('UICorner')
    toggleCorner.CornerRadius = UDim.new(0, 4)
    toggleCorner.Parent = toggle

    local toggleGlow = Instance.new('UIStroke')
    toggleGlow.Parent = toggle
    toggleGlow.Thickness = 2
    toggleGlow.Color = Color3.fromRGB(0, 255, 100)
    toggleGlow.Transparency = 1

    -- Status indicator
    local statusLabel = Instance.new('TextLabel')
    statusLabel.Size = UDim2.new(0, 20, 0, 15)
    statusLabel.Position = UDim2.new(1, -60, 0, 30)
    statusLabel.BackgroundTransparency = 1
    statusLabel.Text = '?'
    statusLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
    statusLabel.Font = Enum.Font.Gotham
    statusLabel.TextSize = 10
    statusLabel.Parent = container

    -- Ingredients/Description label
    local descLabel = Instance.new('TextLabel')
    descLabel.Size = UDim2.new(1, -80, 0, 15)
    descLabel.Position = UDim2.new(0, 10, 0, 35)
    descLabel.BackgroundTransparency = 1
    descLabel.Text = ingredients
    descLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
    descLabel.Font = Enum.Font.Gotham
    descLabel.TextSize = 10
    descLabel.TextXAlignment = Enum.TextXAlignment.Left
    descLabel.Parent = container

    local listening = false

    local function updateToggle()
        local isActive = getgenv().PotionToggles[potionType]

        if isAutoCollection then
            -- Auto-collection toggle logic
            if isActive then
                toggle.BackgroundColor3 = Color3.fromRGB(0, 255, 100)
                toggleGlow.Transparency = 0
                statusLabel.Text = 'ON'
                statusLabel.TextColor3 = Color3.fromRGB(0, 255, 100)
            else
                toggle.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
                toggleGlow.Transparency = 1
                statusLabel.Text = 'OFF'
                statusLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
            end
        else
            -- Potion toggle logic
            local hasCauldron = getAssignedCauldron(potionType) ~= nil

            if isActive and hasCauldron then
                toggle.BackgroundColor3 = Color3.fromRGB(0, 255, 100)
                toggleGlow.Transparency = 0
                statusLabel.Text = 'âœ“'
                statusLabel.TextColor3 = Color3.fromRGB(0, 255, 100)
            elseif isActive and not hasCauldron then
                toggle.BackgroundColor3 = Color3.fromRGB(255, 150, 0)
                toggleGlow.Transparency = 1
                statusLabel.Text = '!'
                statusLabel.TextColor3 = Color3.fromRGB(255, 150, 0)
            else
                toggle.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
                toggleGlow.Transparency = 1
                statusLabel.Text = 'âœ—'
                statusLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
            end
        end

        keyLabel.Text = '[' .. keyToString(getgenv().PotionKeybinds[potionType]) .. ']'
    end

    -- Toggle function
    local function handleToggle()
        local newState = not getgenv().PotionToggles[potionType]
        getgenv().PotionToggles[potionType] = newState

        if isAutoCollection then
            -- Toggle auto-collection
            if newState then
                startAutoCollection()
            else
                stopAutoCollection()
            end
        else
            -- Toggle potion crafting
            if newState then
                if not assignCauldronToPotion(potionType) then
                    getgenv().PotionToggles[potionType] = false -- Revert if no cauldron available
                end
            else
                releaseCauldron(potionType)
            end
        end

        updateToggle()
    end

    -- Click handlers
    toggle.MouseButton1Click:Connect(handleToggle)
    
    local debounce = false
    container.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 and not debounce then
            debounce = true
            handleToggle()
            task.wait(0.2)
            debounce = false
        end
    end)

    -- Rebind functionality
    rebindBtn.MouseButton1Click:Connect(function()
        if listening then return end

        listening = true
        rebindBtn.Text = 'Press Key...'
        rebindBtn.BackgroundColor3 = Color3.fromRGB(70, 70, 70)

        local connection
        connection = UserInputService.InputBegan:Connect(function(input, processed)
            if processed then return end

            if input.UserInputType == Enum.UserInputType.Keyboard then
                getgenv().PotionKeybinds[potionType] = input.KeyCode
                rebindBtn.Text = 'Rebind'
                rebindBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
                updateToggle()
                listening = false
                connection:Disconnect()
                KeybindManager:SaveKeybinds()
            end
        end)
    end)

    potionRows[potionType] = {
        update = updateToggle,
        statusLabel = statusLabel,
        isAutoCollection = isAutoCollection,
    }

    updateToggle()
    return container
end

-- Create potion rows
createPotionRow('Sleep', 0, '3 Mushrooms', false)
createPotionRow('Heal', 65, '3 Wild Flowers', false)
createPotionRow('Shield', 130, '2 Thorns + 1 Flower', false)
createPotionRow('Poison', 195, '2 Mushrooms + 1 Thorn', false)
createPotionRow('AutoCollection', 260, 'Auto-collect resources (F6)', true)

-- Status label
local statusLabel = Instance.new('TextLabel')
statusLabel.Size = UDim2.new(1, -20, 0, 20)
statusLabel.Position = UDim2.new(0, 10, 1, -25)
statusLabel.BackgroundTransparency = 1
statusLabel.Text = 'Initializing...'
statusLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
statusLabel.Font = Enum.Font.Gotham
statusLabel.TextSize = 12
statusLabel.TextXAlignment = Enum.TextXAlignment.Left
statusLabel.Parent = Frame

-- GUI Toggle Functionality
local function updateGUIToggleDisplay()
    Title.Text = 'Potion Crafter\nHide: [' .. keyToString(getgenv().GUIToggleKeybind) .. ']'
end

guiRebindBtn.MouseButton1Click:Connect(function()
    if guiRebindListening then return end

    guiRebindListening = true
    guiRebindBtn.Text = 'Press Key...'
    guiRebindBtn.BackgroundColor3 = Color3.fromRGB(70, 70, 70)

    local connection
    connection = UserInputService.InputBegan:Connect(function(input, processed)
        if processed then return end

        if input.UserInputType == Enum.UserInputType.Keyboard then
            getgenv().GUIToggleKeybind = input.KeyCode
            guiRebindBtn.Text = 'Rebind Hide'
            guiRebindBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
            updateGUIToggleDisplay()
            guiRebindListening = false
            connection:Disconnect()
            KeybindManager:SaveKeybinds()
        end
    end)
end)

-- HIGHLY OPTIMIZED AUTO-COLLECTION SYSTEM
local function stopAutoCollection()
    if HeartbeatConnection then
        HeartbeatConnection:Disconnect()
        HeartbeatConnection = nil
    end
    statusLabel.Text = 'Auto Collection: OFF'
end

local function startAutoCollection()
    if not getgenv().PotionToggles.AutoCollection then return end
    if not collectRemote then
        statusLabel.Text = 'Auto Collection: ERROR - No remote'
        return
    end

    stopAutoCollection()

    statusLabel.Text = 'Auto Collection: ON - Scanning...'

    HeartbeatConnection = RunService.Heartbeat:Connect(function()
        if not getgenv().PotionToggles.AutoCollection then
            stopAutoCollection()
            return
        end

        local currentTime = tick()
        if currentTime - LastScanTime < ScanInterval then return end
        LastScanTime = currentTime

        local character = player.Character
        if not character then return end

        local rootPart = character:FindFirstChild('HumanoidRootPart')
        if not rootPart then return end

        local rootPosition = rootPart.Position
        local collectedThisScan = 0
        local maxRangeSquared = 27 * 27

        -- Pre-calculate resource patterns for faster matching
        for _, resourceName in ipairs(resourceNames) do
            -- Use workspace GetChildren for faster iteration
            local workspaceChildren = workspace:GetChildren()
            for i = 1, #workspaceChildren do
                local item = workspaceChildren[i]
                
                if not getgenv().PotionToggles.AutoCollection then return end
                
                if item:IsA('Model') and item.Name == resourceName then
                    local itemId = item:GetAttribute('Id')
                    if itemId then
                        local itemPos = item:GetPivot().Position
                        local distanceSquared = (itemPos - rootPosition).Magnitude

                        if distanceSquared <= maxRangeSquared then
                            local success = pcall(function()
                                collectRemote:FireServer({
                                    id = itemId,
                                    collectableName = resourceName,
                                })
                            end)

                            if success then
                                collectedThisScan = collectedThisScan + 1
                                -- Minimal delay for performance
                                if collectedThisScan % 5 == 0 then
                                    task.wait(0.01)
                                end
                            end
                        end
                    end
                end
            end
        end

        -- Update status efficiently
        if collectedThisScan > 0 then
            statusLabel.Text = 'Auto Collection: Collected ' .. collectedThisScan .. ' items!'
        else
            ScanCount = ScanCount + 1
            if ScanCount % 10 == 0 then -- Update less frequently when no items found
                statusLabel.Text = 'Auto Collection: Scanning... (' .. ScanCount .. ' scans)'
            end
        end
    end)
end

-- OPTIMIZED INPUT HANDLER
local inputDebounce = false
UserInputService.InputBegan:Connect(function(input, processed)
    if processed or inputDebounce then return end
    inputDebounce = true

    -- GUI Toggle
    if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == getgenv().GUIToggleKeybind then
        Frame.Visible = not Frame.Visible
    end

    -- Potion Keybinds
    if input.UserInputType == Enum.UserInputType.Keyboard then
        for potionType, keybind in pairs(getgenv().PotionKeybinds) do
            if input.KeyCode == keybind then
                local isAutoCollection = potionType == 'AutoCollection'
                local newState = not getgenv().PotionToggles[potionType]
                getgenv().PotionToggles[potionType] = newState

                if isAutoCollection then
                    if newState then
                        startAutoCollection()
                    else
                        stopAutoCollection()
                    end
                else
                    if newState then
                        if not assignCauldronToPotion(potionType) then
                            getgenv().PotionToggles[potionType] = false
                        end
                    else
                        releaseCauldron(potionType)
                    end
                end

                if potionRows[potionType] then
                    potionRows[potionType].update()
                end
                break
            end
        end
    end

    task.wait(0.1)
    inputDebounce = false
end)

-- OPTIMIZED POTION CRAFTING LOOPS
local function createPotionLoop(potionType, ingredients)
    return function()
        local lastCraftTime = 0
        local craftDebounce = 0.1
        
        while true do
            task.wait(0.5) -- Reduced frequency for performance
            
            if getgenv().PotionToggles[potionType] then
                local currentTime = tick()
                if currentTime - lastCraftTime < craftDebounce then
                    continue
                end
                
                local cauldron = getAssignedCauldron(potionType)

                if not cauldron then
                    if assignCauldronToPotion(potionType) then
                        cauldron = getAssignedCauldron(potionType)
                        if potionRows[potionType] then
                            potionRows[potionType].update()
                        end
                    else
                        task.wait(1)
                        continue
                    end
                end

                local canCraft = false
                if potionType == 'Sleep' then
                    canCraft = getItemCount('mushrooms') >= 3
                elseif potionType == 'Heal' then
                    canCraft = getItemCount('wild_flower') >= 3
                elseif potionType == 'Shield' then
                    canCraft = getItemCount('thorns') >= 2 and getItemCount('wild_flower') >= 1
                elseif potionType == 'Poison' then
                    canCraft = getItemCount('mushrooms') >= 2 and getItemCount('thorns') >= 1
                end

                if canCraft and cauldron then
                    -- Optimized deposit sequences
                    local depositItems = {}
                    if potionType == 'Sleep' then
                        depositItems = {'mushrooms', 'mushrooms', 'mushrooms'}
                    elseif potionType == 'Heal' then
                        depositItems = {'wild_flower', 'wild_flower', 'wild_flower'}
                    elseif potionType == 'Shield' then
                        depositItems = {'thorns', 'thorns', 'wild_flower'}
                    elseif potionType == 'Poison' then
                        depositItems = {'mushrooms', 'mushrooms', 'thorns'}
                    end

                    for _, item in ipairs(depositItems) do
                        if getItemCount(item) >= 1 then
                            depositItem(cauldron, item)
                            task.wait(depositInterval)
                        end
                    end

                    -- Wait for crafting completion
                    local startTime = tick()
                    while tick() - startTime < craftWait do
                        task.wait(0.5)
                    end

                    collectPotion(cauldron)
                    lastCraftTime = tick()
                end
            end
        end
    end
end

-- Create and start all potion loops
coroutine.wrap(createPotionLoop('Sleep', '3 Mushrooms'))()
coroutine.wrap(createPotionLoop('Heal', '3 Wild Flowers'))()
coroutine.wrap(createPotionLoop('Shield', '2 Thorns + 1 Flower'))()
coroutine.wrap(createPotionLoop('Poison', '2 Mushrooms + 1 Thorn'))()

-- OPTIMIZED STATUS UPDATER
local statusUpdateCount = 0
task.spawn(function()
    while task.wait(2) do
        statusUpdateCount = statusUpdateCount + 1
        
        -- Only update cauldron info every few cycles for performance
        if statusUpdateCount % 3 == 0 then
            local allCauldrons = findAllCauldronsSorted()
            local activeCount = 0
            local assignmentText = ''

            for potionType, _ in pairs(getgenv().PotionToggles) do
                if getgenv().PotionToggles[potionType] and potionType ~= 'AutoCollection' then
                    activeCount = activeCount + 1
                    if getAssignedCauldron(potionType) then
                        assignmentText = assignmentText .. potionType .. ' '
                    end
                end
            end

            if assignmentText == '' then
                assignmentText = 'None'
            end

            if not getgenv().PotionToggles.AutoCollection or not statusLabel.Text:find('Auto Collection') then
                statusLabel.Text = 'Cauldrons: ' .. #allCauldrons .. ' | Active: ' .. activeCount .. ' | Assignments: ' .. assignmentText
            end
        end

        -- Update potion rows less frequently
        if statusUpdateCount % 2 == 0 then
            for potionType, row in pairs(potionRows) do
                row.update()
            end
        end
    end
end)

-- Start auto-collection if enabled
if getgenv().PotionToggles.AutoCollection then
    task.wait(2)
    startAutoCollection()
end

updateGUIToggleDisplay()

print('ðŸš€ Optimized Potion Crafter Loaded Successfully!')
print('âš¡ Enhanced performance with caching and optimized logic')
print('ðŸ”§ Heal Potion: PageUp | Hide GUI: PageDown')
print('ðŸ“¦ Auto-Collection: F6 | Multi-cauldron support')
print('ðŸŽ¯ Real-time auto-collection with 27 stud reach enabled')
